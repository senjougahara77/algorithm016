# 学习笔记  第一周的学习心得  
之前报了算法训练营体验班，感觉还不错，我个人更看重的一点是有老师可以督促自己并且有一起学习进步的同学，这一点很棒。通过第一周简单学习，并且参与了刷题狂魔组，感受到了逐渐培养起来的每日刷题的好习惯。同时也体会到了自己解决每一道题的成就感。  
第一周学的一些简单数据结构中，感觉目前最不熟练的还是链表的题，而链表的题又多半数递归解法，本质上还是递归的思维没有建立起来，不容易从这个方向考虑问题。接下来会着重强化这个部分的练习。接下来要学的树这一部分，递归也是重点。除此之外，跟着超哥做了两道hard的题目，深感熟练很重要，现场思考解题几乎不可能，必须在这之前就做过类似的题，有过积累才行。希望接下来继续努力坚持。
本周只上传了两道题解，因为都是在网站写的。之后会在IDEA里面写，并且上传所有代码。  

# 这一周做过的题目
## #21 合并两个有序链表	简单  
记住递归的思维方式，链表中常用递归来解决，需要分析出最小子问题，代码一般比较简洁。
## #239 滑动窗口最大值	困难	
所有滑动窗口的题目，解法都很类似。这道题使用双端队列即可解决。每次讲新元素addFirst，同时需要pollLast队列中所有小于当前元素的已有元素（while循环实现）。  
记住让队列中不超过k个元素的写法：  
for (int i = 0; i < nums.length; i++) {
    if (!temp.isEmpty() && temp.peekFirst() <= i - k) {
        temp.pollFirst();
    }  
## #84 柱状图中最大的矩形	困难	
第一道hard题，花了些时间想明白。使用单端stack可以解决。这种方法不容易想到，必须牢记背熟。特别注意要在最后添加“哨兵”元素“0”，这样才可以处理所有柱状相等或者递增的情况。
## #155 最小栈	简单  
写一个可以随时提供栈内最小值的栈。多用一个栈就可以解决，保持辅助栈顶值永远最小，在每次push和pop时进行判断。
## #189 旋转数组	简单  
不太容易想到的思路：  
这个方法基于这个事实：当我们旋转数组 k 次， k\%nk%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。
在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-kn−k 个元素，就能得到想要的结果。
假设 n=7 且 k=3。
## #20 有效的括号	简单	
用stack就可以完成，思路在于每次检测左括号就push对应右括号，便于之后检测右括号。
## #24 两两交换链表中的节点	中等	
两边跑的题应当想到递归的方法，最小子问题就是前两个节点的交换，之后直接使用递归完成。
## #15 三数之和	中等  
算法是先排序 Array.sort(); 再双指针，若两数之和大于负i，尾指针左移，反之头指针（从1位置开始）右移。  
最精妙的判重代码如下：  
while (j < k && nums[j] == nums[++j]);
## #1 两数之和	简单  
lc的第一题，很经典。暴力解法时间复杂度O(n2)，此外可以直接用哈希表解决，之后几周会具体讲。  
有关哈希表的几个语法：  
HashMap<Integer,Integer> sum = new HashMap<>();
sum.containsKey(nums[i])
sum.put(target - nums[i],i);
## #66 加一	简单
本题最巧妙的思路在于，对于每一位只需要检测是否为9。是就置零，否则+1，一旦+1就直接return结果即可。无需使用新数组放进位。  
另外需要一个新数组来处理所有位都为9的情况。
## #70 爬楼梯	简单
递归问题，同理与斐波那契数列。但是递归会超时，这里使用动态规划，每次存储之前两个值和他们的和，不断更新即可。
## #141 环形链表	简单	
检测链表中是否有环，简单暴力遍历可解。同时也可以利用快慢指针，因为存在环，快指针一定会套环慢指针。
## #1137 第 N 个泰波那契数	简单
等于斐波那契，递归会超时，使用动态规划，每次存储三个值和他们的和，类似于爬楼梯的问题。
## #104 二叉树的最大深度	简单	
数的问题一般都是递归，最小子问题就是最小二叉树的处理。对左右子树同时使用该函数，取最大值Math.max()，结果在此基础上+1即可。

